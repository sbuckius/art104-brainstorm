<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Collaborative Brainstorming</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
body { font-family: Arial; max-width: 1000px; margin:auto; padding:20px; background:#f5f5f5; }
h1,h2 { color:#333; }
input, select, button, textarea { font-size:1rem; padding:8px; margin:5px 0; }
textarea { resize: vertical; min-height:50px; width: 100%; box-sizing: border-box; }
#groupPage { display:none; }
.step { background:#fff; padding:15px; margin:10px 0; border-radius:8px; border-left:6px solid #4CAF50; }
.responses { display:flex; gap:10px; flex-wrap:wrap; margin-top:10px; }
.response-item { flex:1; min-width:200px; }
.user-label { font-weight:bold; display:block; margin-bottom:3px; padding:3px 6px; border-radius:3px; color:white; }
.typing { font-size:0.85rem; color:#555; font-style:italic; min-height:18px; }
.avatar { display:inline-block; padding:5px 10px; margin:2px; border-radius:5px; color:white; font-weight:bold; }
.leader { border:2px solid gold; }
#resetBtn { background: #f44336; color: white; }
</style>
</head>
<body>

<div id="lobbyPage">
<h1>Brainstorm Lobby</h1>
<p>Enter your avatar name:</p>
<input type="text" id="avatarName" placeholder="Avatar Name">
<p>Select group (1–10):</p>
<select id="groupSelect">
  <option value="">-- Choose a group --</option>
  <option value="1">Group 1</option>
  <option value="2">Group 2</option>
  <option value="3">Group 3</option>
  <option value="4">Group 4</option>
  <option value="5">Group 5</option>
  <option value="6">Group 6</option>
  <option value="7">Group 7</option>
  <option value="8">Group 8</option>
  <option value="9">Group 9</option>
  <option value="10">Group 10</option>
</select>
<br><br>
<button id="joinGroupBtn">Join Group</button>
<div id="lobbyMessage"></div>
</div>

<div id="groupPage">
<h1 id="groupTitle"></h1>
<div id="avatars"></div>
<div id="processSelectionDiv" style="margin:10px 0;"></div>
<button id="exportBtn">Export PDF</button>
<button id="resetBtn">Reset Group Data</button>
<div id="processSteps"></div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getFirestore, doc, setDoc, getDoc, onSnapshot, updateDoc, arrayUnion, serverTimestamp, deleteDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBEn-_qOw_6k-v6qjHvSfthNJwvUwdzEI0",
  authDomain: "art104-brainstorm-space.firebaseapp.com",
  projectId: "art104-brainstorm-space",
  storageBucket: "art104-brainstorm-space.firebasestorage.app",
  messagingSenderId: "809793310505",
  appId: "1:809793310505:web:8bd39b8eb465c784f67138",
  measurementId: "G-LND87XNSBT"
};
const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const avatarNameInput = document.getElementById("avatarName");
const groupSelect = document.getElementById("groupSelect");
const joinGroupBtn = document.getElementById("joinGroupBtn");
const lobbyPage = document.getElementById("lobbyPage");
const groupPage = document.getElementById("groupPage");
const groupTitle = document.getElementById("groupTitle");
const avatarsDiv = document.getElementById("avatars");
const processSelectionDiv = document.getElementById("processSelectionDiv");
const processStepsDiv = document.getElementById("processSteps");
const exportBtn = document.getElementById("exportBtn");
const resetBtn = document.getElementById("resetBtn");

const userColors = ["#FF6F61","#6B5B95","#88B04B","#F7CAC9"];
let username="", groupNum="", currentDocRef=null, isLeader=false, currentProcessKey="";
let stepsRendered = false; // Track if steps UI has been created

const processes = {
  prosCons: ["List sketches", "Discuss strengths", "Write pros/cons", "Decide strongest", "Refine top ideas"],
  mergeIdeas: ["Review sketches", "Combine elements", "Discuss cohesion", "Refine merged", "Adjust"],
  ranking: ["Set criteria", "Rank sketches", "Top 3", "Eliminate weak", "Finalize strongest"],
  peerFeedback: ["Present sketches", "Collect feedback", "Find themes", "Choose best", "Refine"],
  storytelling: ["Create narrative", "Evaluate clarity", "Check alignment", "Choose strongest", "Refine"],
  collectiveConcept: ["Each user contributes a phrase", "Review contributions", "Discuss connections", "Write final combined sentence"]
};

resetBtn.addEventListener("click", async () => {
  if(!currentDocRef) {
    alert("No group to reset!");
    return;
  }
  
  if(confirm("This will DELETE ALL DATA for this group and restart fresh. Are you sure?")) {
    await deleteDoc(currentDocRef);
    alert("Group deleted! Refreshing page...");
    location.reload();
  }
});

joinGroupBtn.addEventListener("click", async () => {
  username = avatarNameInput.value.trim();
  groupNum = groupSelect.value;
  if(!username||!groupNum){ alert("Enter avatar name and select a group."); return; }

  const docId = `group_${groupNum}`;
  currentDocRef = doc(db,"groups",docId);

  const snap = await getDoc(currentDocRef);
  if(!snap.exists()){
    await setDoc(currentDocRef,{
      members:[{name:username,color:userColors[0],leader:true}],
      process:"",
      steps:[],
      lastUpdated:serverTimestamp()
    });
    isLeader = true;
  } else {
    const data = snap.data();
    const members = data.members || [];
    if(members.length>=4){ alert("Group full!"); return; }
    
    const existingIndex = members.findIndex(m => m.name === username);
    if(existingIndex >= 0){
      isLeader = members[existingIndex].leader;
    } else {
      const color = userColors[members.length];
      await updateDoc(currentDocRef,{members:arrayUnion({name:username,color,leader:false})});
      isLeader = false;
    }
  }

  lobbyPage.style.display="none";
  groupPage.style.display="block";
  groupTitle.textContent = `Group ${groupNum}`;
  setupGroupUI();
});

function setupGroupUI(){
  onSnapshot(currentDocRef, snap=>{
    if(!snap.exists()) return;
    
    const data = snap.data();

    // Show avatars
    avatarsDiv.innerHTML="";
    data.members.forEach(m=>{
      const span=document.createElement("span");
      span.className="avatar";
      if(m.leader) span.classList.add("leader");
      span.style.backgroundColor=m.color;
      span.textContent=m.name + (m.leader?" (Leader)":"");
      avatarsDiv.appendChild(span);
    });

    // Leader selects process
    if(isLeader && !data.process){
      processSelectionDiv.innerHTML='<select id="processSelectLeader"><option value="">-- Choose a process --</option></select><button id="startProcessBtn">Start Process</button>';
      const select=document.getElementById("processSelectLeader");
      Object.keys(processes).forEach(k=>{
        const opt=document.createElement("option");
        opt.value=k; opt.textContent=k;
        select.appendChild(opt);
      });
      
      document.getElementById("startProcessBtn").addEventListener("click", async ()=>{
        const selectedProcess = select.value;
        if(!selectedProcess) { alert("Select a process first!"); return; }
        currentProcessKey = selectedProcess;
        
        const stepData = processes[currentProcessKey].map(text=>{
          const responses = {};
          const typing = {};
          data.members.forEach((m) => {
            responses[m.name] = "";
            typing[m.name] = "";
          });
          return {text, responses, typing};
        });
        
        await setDoc(currentDocRef, {
          members: data.members,
          process: currentProcessKey,
          steps: stepData,
          lastUpdated: serverTimestamp()
        });
        
        stepsRendered = false; // Allow re-render with new process
      });
    } else if(data.process){
      processSelectionDiv.innerHTML = `<b>Process:</b> ${data.process}`;
      currentProcessKey = data.process;
    } else {
      processSelectionDiv.innerHTML = "Waiting for leader to select process...";
    }

    // Validate and render/update steps
    if(data.process && data.steps && Array.isArray(data.steps) && data.steps.length > 0){
      if(!stepsRendered) {
        // First time: create the UI
        renderSteps(data.steps, data.members);
        stepsRendered = true;
      } else {
        // Subsequent times: just update values without re-rendering
        updateStepValues(data.steps, data.members);
      }
    } else if(data.process && (!data.steps || !Array.isArray(data.steps))) {
      processStepsDiv.innerHTML = '<p style="color:red; font-size:1.2em; padding:20px; background:white; border-radius:8px;">ERROR: Data corrupted. Click "Reset Group Data" button above to fix.</p>';
      stepsRendered = false;
    }
  });
}

function renderSteps(steps, members){
  processStepsDiv.innerHTML="";
  
  steps.forEach((step,stepIndex)=>{
    const div=document.createElement("div");
    div.className="step";
    const title=document.createElement("div");
    title.innerHTML = `<strong>${step.text}</strong>`;
    div.appendChild(title);

    const responsesDiv=document.createElement("div");
    responsesDiv.className="responses";

    members.forEach((member)=>{
      const respDiv=document.createElement("div");
      respDiv.className="response-item";
      
      const label=document.createElement("div");
      label.className="user-label"; 
      label.textContent=member.name;
      label.style.backgroundColor=member.color;

      const ta=document.createElement("textarea");
      ta.id = `step${stepIndex}_${member.name}`;
      ta.value = step.responses[member.name] || "";
      ta.disabled = (member.name !== username);
      
      if(member.name === username){
        ta.style.backgroundColor = "#fff";
        ta.style.border = `2px solid ${member.color}`;
      } else {
        ta.style.backgroundColor = "#f0f0f0";
      }

      let typingTimeout;
      ta.addEventListener("input", async ()=>{
        const updatedResponses = {...step.responses};
        updatedResponses[username] = ta.value;
        const updatedTyping = {...step.typing};
        updatedTyping[username] = username;
        
        try {
          await updateDoc(currentDocRef,{
            [`steps.${stepIndex}.responses`]: updatedResponses,
            [`steps.${stepIndex}.typing`]: updatedTyping,
            lastUpdated: serverTimestamp()
          });
        } catch(err) {
          console.error("Update error:", err);
        }
        
        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(async ()=>{
          const clearTyping = {...step.typing};
          clearTyping[username] = "";
          await updateDoc(currentDocRef,{[`steps.${stepIndex}.typing`]: clearTyping});
        }, 1000);
      });

      const typingSpan=document.createElement("div");
      typingSpan.className="typing";
      typingSpan.id = `typing${stepIndex}_${member.name}`;
      const typingUser = step.typing[member.name];
      typingSpan.textContent = (typingUser && typingUser !== "" && member.name !== username) ? `✏️ Typing...` : "";

      respDiv.appendChild(label);
      respDiv.appendChild(ta);
      respDiv.appendChild(typingSpan);
      responsesDiv.appendChild(respDiv);
    });

    div.appendChild(responsesDiv);
    processStepsDiv.appendChild(div);
  });
}

// Update values WITHOUT re-rendering
function updateStepValues(steps, members){
  steps.forEach((step, stepIndex) => {
    members.forEach(member => {
      const ta = document.getElementById(`step${stepIndex}_${member.name}`);
      const typingSpan = document.getElementById(`typing${stepIndex}_${member.name}`);
      
      if(ta && member.name !== username){
        // Only update OTHER users' textareas (not your own to prevent cursor jump)
        ta.value = step.responses[member.name] || "";
      }
      
      if(typingSpan){
        const typingUser = step.typing[member.name];
        typingSpan.textContent = (typingUser && typingUser !== "" && member.name !== username) ? `✏️ Typing...` : "";
      }
    });
  });
}

exportBtn.addEventListener("click", async ()=>{
  if(!currentDocRef) {
    alert("Group not started.");
    return;
  }
  
  const snap = await getDoc(currentDocRef);
  if(!snap.exists()) { 
    alert("No data found!");
    return;
  }
  
  const data = snap.data();
  
  if(!data.process || !data.steps || !Array.isArray(data.steps)) {
    alert("ERROR: Data is corrupted or no process started. Click 'Reset Group Data' to fix.");
    return;
  }
  
  if(!window.jspdf) {
    alert("PDF library not loaded!");
    return;
  }
  
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF();
  let y=20;
  
  pdf.setFontSize(16); 
  pdf.setFont(undefined, 'bold');
  pdf.text(`Group ${groupNum}`,20,y); 
  y+=10;
  
  pdf.setFontSize(12); 
  pdf.text(`Process: ${data.process}`,20,y); 
  y+=15;

  data.steps.forEach((step)=>{
    if(y > 270) { pdf.addPage(); y = 20; }
    
    pdf.setFontSize(12);
    pdf.setFont(undefined,"bold"); 
    pdf.text(step.text, 20, y); 
    y+=8;
    
    pdf.setFontSize(10);
    pdf.setFont(undefined,"normal");
    
    data.members.forEach(member=>{
      const response = step.responses[member.name];
      if(response && response.trim()){
        const lines = pdf.splitTextToSize(`${member.name}: ${response}`, 170);
        
        if(y + (lines.length * 6) > 280) { pdf.addPage(); y = 20; }
        
        pdf.text(lines, 25, y);
        y += lines.length * 6 + 2;
      }
    });
    
    y += 5;
  });

  pdf.save(`Group${groupNum}_${data.process}.pdf`);
  alert("PDF exported successfully!");
});
</script>
</body>
</html>