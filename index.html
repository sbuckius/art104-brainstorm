<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Collaborative Sketch Process</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  body { font-family: Arial; max-width: 900px; margin: auto; padding: 20px; background: #f5f5f5; }
  h1, h2 { color: #333; }
  select, button, textarea, input[type=file], input[type=text] { font-size: 1rem; padding: 8px; margin: 5px 0; }
  .step { background: #fff; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 6px solid #4CAF50; }
  .step input[type="checkbox"] { margin-right: 10px; }
  .step textarea { width: 100%; margin-top: 5px; }
  .step img { max-width: 200px; display: block; margin-top: 5px; border: 1px solid #ccc; border-radius: 5px; }
  .editing-label { color: red; font-weight: bold; margin-top: 5px; }
  .phrase-input { width: 100%; padding: 10px; margin: 10px 0; font-size: 1rem; border: 2px solid #4CAF50; border-radius: 5px; }
  .phrase-list { background: #f9f9f9; padding: 15px; margin: 10px 0; border-radius: 5px; }
  .phrase-item { padding: 8px; margin: 5px 0; background: white; border-left: 3px solid #2196F3; border-radius: 3px; }
  .phrase-author { font-weight: bold; color: #2196F3; margin-right: 10px; }
  .final-concept { background: #fff3cd; padding: 20px; margin: 20px 0; border-radius: 8px; border: 2px solid #ffc107; }
  .final-concept h3 { color: #856404; margin-top: 0; }
</style>
</head>
<body>

<h1>Collaborative Sketch to Final Idea</h1>

<p>Enter your name for collaboration:</p>
<input type="text" id="username" placeholder="Your Name">

<p>Enter a group name (used for shared collaboration):</p>
<input type="text" id="groupName" placeholder="Group Name">

<select id="processSelect">
  <option value="">-- Choose a process --</option>
  <option value="prosCons">Pros and Cons Analysis</option>
  <option value="mergeIdeas">Merge & Combine Ideas</option>
  <option value="ranking">Ranking & Elimination</option>
  <option value="peerFeedback">Peer Review & Feedback</option>
  <option value="storytelling">Storytelling & Perspective</option>
  <option value="wackyCorpse">Wacky Exquisite Corpse</option>
  <option value="collectiveConcept">Collective Concept Builder</option>
</select>

<button id="startBtn">Start / Join Process</button>
<button id="exportBtn">Export PDF</button>

<div id="processSteps"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getFirestore, doc, onSnapshot, setDoc, updateDoc, arrayUnion, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBAXjYxu0Nw59omDOk7qLQ2xzMRMRTBQ4g",
  authDomain: "art104-brainstorm.firebaseapp.com",
  projectId: "art104-brainstorm",
  storageBucket: "art104-brainstorm.firebasestorage.app",
  messagingSenderId: "333611557857",
  appId: "1:333611557857:web:610e1926f3886aaeb5a8a0",
  measurementId: "G-X3C9CHJ1BS"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);

const processes = {
  prosCons: ["List all 10 sketches.", "Discuss strengths and weaknesses.", "Write pros and cons.", "Decide strongest sketches.", "Narrow to 2‚Äì3 sketches to refine."],
  mergeIdeas: ["Review sketches, identify best elements.", "Sketch combinations of strong elements.", "Discuss which merged sketches are cohesive.", "Refine one merged idea.", "Evaluate against goals and adjust."],
  ranking: ["Establish evaluation criteria.", "Rank each sketch.", "Identify top 3 sketches.", "Remove weaker sketches, refine remaining.", "Finalize strongest sketch."],
  peerFeedback: ["Present sketches to other group.", "Collect feedback on strongest sketches.", "Discuss feedback and find common themes.", "Choose sketch fitting feedback.", "Refine into final idea."],
  storytelling: ["Imagine story for each sketch.", "Evaluate clearest story.", "Discuss how story supports goals.", "Select strongest narrative sketch.", "Refine into final idea."],
  wackyCorpse: ["Add your sketch (without seeing the full previous sketches).", "Next participant can only see the last uploaded image.", "Add a creative twist to the partial sketch.", "Repeat until all group members have contributed.", "Reveal the final combined sketch and discuss!"],
  collectiveConcept: ["Each member contributes a phrase, sentence, or theme.", "Review all contributions.", "Discuss how phrases connect or contrast.", "Synthesize into a unified concept.", "Refine the final collective concept."]
};

let currentDocRef;
let currentProcessKey;

function startProcess() {
  const username = document.getElementById("username").value.trim();
  const groupName = document.getElementById("groupName").value.trim();
  currentProcessKey = document.getElementById("processSelect").value;

  if (!username || !groupName || !currentProcessKey) {
    alert("Enter your name, group name, and select a process.");
    return;
  }

  const processId = groupName.replace(/\s+/g,'_');
  currentDocRef = doc(db, "processes", processId);

  const initialData = {
    groupName,
    steps: processes[currentProcessKey].map(text => ({text, checked:false, note:"", images:[] })),
    editing: {},
    lastUpdated: serverTimestamp()
  };

  if (currentProcessKey === "collectiveConcept") {
    initialData.phrases = [];
  }

  setDoc(currentDocRef, initialData, {merge:true});

  onSnapshot(currentDocRef, (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      renderSteps(data.steps, currentProcessKey, data.editing || {}, data.phrases || []);
    }
  });
}

function renderSteps(steps, processKey, editingMap={}, phrases=[]) {
  const stepsDiv = document.getElementById("processSteps");

  const currentNotes = {};
  steps.forEach((step, index) => {
    const ta = document.getElementById(`note${index}`);
    if (ta) currentNotes[index] = ta.value;
  });

  stepsDiv.innerHTML = '';
  const username = document.getElementById("username").value.trim();

  if (processKey === "collectiveConcept") {
    const phraseDiv = document.createElement('div');
    phraseDiv.className = 'step';
    
    const userHasContributed = phrases.some(p => p.author === username);
    
    phraseDiv.innerHTML = `
      <h3>üí° Contribute Your Phrase/Theme</h3>
      <input type="text" id="phraseInput" class="phrase-input" placeholder="Enter your phrase, sentence, or theme..." ${userHasContributed ? 'disabled' : ''}>
      <button id="addPhraseBtn" ${userHasContributed ? 'disabled' : ''}>Add My Contribution</button>
      ${userHasContributed ? '<p style="color: green;">‚úì You have already contributed!</p>' : ''}
    `;
    stepsDiv.appendChild(phraseDiv);

    if (phrases.length > 0) {
      const phraseListDiv = document.createElement('div');
      phraseListDiv.className = 'phrase-list';
      phraseListDiv.innerHTML = '<h3>üìù Group Contributions:</h3>';
      
      phrases.forEach(phrase => {
        const phraseItem = document.createElement('div');
        phraseItem.className = 'phrase-item';
        phraseItem.innerHTML = `<span class="phrase-author">${phrase.author}:</span> ${phrase.text}`;
        phraseListDiv.appendChild(phraseItem);
      });
      
      stepsDiv.appendChild(phraseListDiv);
    }

    if (!userHasContributed) {
      setTimeout(() => {
        const addBtn = document.getElementById('addPhraseBtn');
        if (addBtn) {
          addBtn.addEventListener('click', addPhrase);
        }
      }, 0);
    }

    if (steps[3] && steps[3].checked && phrases.length > 0) {
      const conceptDiv = document.createElement('div');
      conceptDiv.className = 'final-concept';
      conceptDiv.innerHTML = `
        <h3>üé® Synthesized Concept</h3>
        <p><strong>Combined themes:</strong> ${phrases.map(p => p.text).join(' ‚Ä¢ ')}</p>
        <textarea id="finalConceptText" class="phrase-input" placeholder="Write the unified concept that emerges from all contributions...">${steps[3].note}</textarea>
      `;
      stepsDiv.appendChild(conceptDiv);

      setTimeout(() => {
        const conceptTextarea = document.getElementById('finalConceptText');
        if (conceptTextarea) {
          conceptTextarea.addEventListener('input', (e) => {
            updateNote(3, e.target.value);
          });
        }
      }, 0);
    }
  }

  steps.forEach((step, index) => {
    const div = document.createElement('div');
    div.className = 'step';

    let imagesHTML = '';
    if (processKey === "wackyCorpse" && step.images.length) {
      const lastImage = step.images[step.images.length - 1];
      imagesHTML = `<img src="${lastImage}">`;
    } else {
      imagesHTML = step.images.map(url => `<img src="${url}">`).join('');
    }

    let editingLabel = '';
    if (editingMap[index] && editingMap[index] !== username) {
      editingLabel = `<div class="editing-label">Editing: ${editingMap[index]}</div>`;
    }

    div.innerHTML = `
      <label>
        <input type="checkbox" id="check${index}" ${step.checked ? 'checked':''} onchange="toggleCheck(${index}, this.checked)">
        ${step.text}
      </label>
      ${editingLabel}
      <textarea id="note${index}" placeholder="Add notes...">${currentNotes[index] !== undefined ? currentNotes[index] : step.note}</textarea>
      <input type="file" id="file${index}" accept="image/*" onchange="uploadCompressedImage(${index}, this.files[0])">
      <div id="images${index}">${imagesHTML}</div>
    `;
    stepsDiv.appendChild(div);

    const textarea = document.getElementById(`note${index}`);

    let typingTimeout;
    textarea.addEventListener('input', e => {
      updateNote(index, e.target.value);
      setEditing(index, true); 
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => setEditing(index, false), 1000); 
    });

    textarea.addEventListener('focus', () => setEditing(index, true));
    textarea.addEventListener('blur', () => setEditing(index, false));
  });
}

async function addPhrase() {
  const username = document.getElementById("username").value.trim();
  const phraseInput = document.getElementById("phraseInput");
  const phraseText = phraseInput.value.trim();

  if (!phraseText) {
    alert("Please enter a phrase or theme!");
    return;
  }

  if (!username) {
    alert("Please enter your name first!");
    return;
  }

  await updateDoc(currentDocRef, {
    phrases: arrayUnion({ author: username, text: phraseText, timestamp: new Date().toISOString() }),
    lastUpdated: serverTimestamp()
  });

  phraseInput.value = '';
}

async function toggleCheck(index, checked) {
  await updateDoc(currentDocRef, { [`steps.${index}.checked`]: checked, lastUpdated: serverTimestamp() });
}

async function updateNote(index, note) {
  await updateDoc(currentDocRef, { [`steps.${index}.note`]: note, lastUpdated: serverTimestamp() });
}

function setEditing(stepIndex, isEditing) {
  const username = document.getElementById("username").value.trim();
  if (!username) return;
  const field = `editing.${stepIndex}`;
  if (isEditing) {
    updateDoc(currentDocRef, { [field]: username });
  } else {
    updateDoc(currentDocRef, { [field]: null });
  }
}

// Store images as base64 to avoid CORS issues
async function uploadCompressedImage(index, file) {
  if (!file) return;
  
  try {
    const img = await loadImageForCompression(file);
    const canvas = document.createElement('canvas');
    const maxWidth = 600; // Smaller to fit in Firestore
    const scale = Math.min(maxWidth / img.width, 1);
    canvas.width = img.width * scale;
    canvas.height = img.height * scale;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
    
    // Convert to base64 data URL
    const base64Image = canvas.toDataURL('image/jpeg', 0.6);
    
    // Store directly in Firestore as base64
    await updateDoc(currentDocRef, { 
      [`steps.${index}.images`]: arrayUnion(base64Image), 
      lastUpdated: serverTimestamp() 
    });
    
  } catch (error) {
    console.error("Error uploading image:", error);
    alert("Error uploading image: " + error.message);
  }
}

function loadImageForCompression(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.src = e.target.result;
      img.onload = () => resolve(img);
    };
    reader.readAsDataURL(file);
  });
}

async function exportPDF() {
  try {
    if (!window.jspdf) {
      alert("ERROR: jsPDF library not loaded!");
      return;
    }

    const { jsPDF } = window.jspdf;
    
    if (!currentDocRef) {
      alert("ERROR: No process started. Please click 'Start / Join Process' first.");
      return;
    }

    const snapshot = await getDoc(currentDocRef);
    
    if (!snapshot.exists()) {
      alert("ERROR: No Firebase data found!");
      return;
    }

    const data = snapshot.data();
    const pdf = new jsPDF();
    let y = 20;
    const pageHeight = 280;
    const margin = 20;

    // Title
    pdf.setFontSize(16);
    pdf.setFont(undefined, 'bold');
    pdf.text(`${data.groupName} - ${currentProcessKey}`, margin, y);
    y += 15;

    // Phrases for collectiveConcept
    if (currentProcessKey === "collectiveConcept" && data.phrases && data.phrases.length > 0) {
      if (y + 20 > pageHeight) { pdf.addPage(); y = margin; }
      
      pdf.setFontSize(14);
      pdf.setFont(undefined, 'bold');
      pdf.text("Group Contributions:", margin, y);
      y += 10;
      
      pdf.setFontSize(11);
      pdf.setFont(undefined, 'normal');
      
      for (const phrase of data.phrases) {
        const text = `${phrase.author}: ${phrase.text}`;
        const lines = pdf.splitTextToSize(text, 170);
        const lineHeight = lines.length * 6;
        
        if (y + lineHeight > pageHeight) { pdf.addPage(); y = margin; }
        
        pdf.text(lines, margin + 5, y);
        y += lineHeight + 3;
      }
      y += 10;
    }

    // Steps
    for (let i = 0; i < data.steps.length; i++) {
      const step = data.steps[i];
      
      if (y + 15 > pageHeight) { pdf.addPage(); y = margin; }
      
      const checkbox = step.checked ? "[‚úì] " : "[ ] ";
      pdf.setFontSize(12);
      pdf.setFont(undefined, 'bold');
      pdf.text(checkbox + step.text, margin, y);
      y += 10;

      if (step.note && step.note.trim()) {
        pdf.setFontSize(10);
        pdf.setFont(undefined, 'normal');
        const noteLines = pdf.splitTextToSize("Notes: " + step.note, 170);
        const noteHeight = noteLines.length * 6;
        
        if (y + noteHeight > pageHeight) { pdf.addPage(); y = margin; }
        
        pdf.text(noteLines, margin + 5, y);
        y += noteHeight + 5;
      }

      // Images (now stored as base64)
      if (step.images && step.images.length > 0) {
        for (const base64Image of step.images) {
          if (y + 55 > pageHeight) { pdf.addPage(); y = margin; }
          
          try {
            // Image is already base64, just add it directly
            pdf.addImage(base64Image, 'JPEG', margin + 5, y, 50, 50);
            y += 55;
          } catch (err) {
            console.error("Image error:", err);
            pdf.setFontSize(9);
            pdf.setTextColor(255, 0, 0);
            pdf.text("[Image could not be loaded]", margin + 5, y);
            pdf.setTextColor(0, 0, 0);
            y += 10;
          }
        }
      }
      
      y += 5;
    }

    pdf.save(`${data.groupName}_${currentProcessKey}.pdf`);

  } catch (error) {
    alert("ERROR: " + error.message);
    console.error("PDF Export Error:", error);
  }
}

window.toggleCheck = toggleCheck;
window.uploadCompressedImage = uploadCompressedImage;

document.getElementById('startBtn').addEventListener('click', startProcess);
document.getElementById('exportBtn').addEventListener('click', exportPDF);

</script>

</body>
</html>