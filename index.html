<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Collaborative Sketch Process</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<style>
  body { font-family: Arial; max-width: 900px; margin: auto; padding: 20px; background: #f5f5f5; }
  h1, h2 { color: #333; }
  select, button, textarea, input[type=file], input[type=text] { font-size: 1rem; padding: 8px; margin: 5px 0; }
  .step { background: #fff; padding: 15px; margin: 10px 0; border-radius: 8px; border-left: 6px solid #4CAF50; }
  .step input[type="checkbox"] { margin-right: 10px; }
  .step textarea { width: 100%; margin-top: 5px; }
  .step img { max-width: 200px; display: block; margin-top: 5px; border: 1px solid #ccc; border-radius: 5px; }
  .editing-label { color: red; font-weight: bold; margin-top: 5px; }
</style>
</head>
<body>

<h1>Collaborative Sketch to Final Idea</h1>

<p>Enter your name for collaboration:</p>
<input type="text" id="username" placeholder="Your Name">

<p>Enter a group name (used for shared collaboration):</p>
<input type="text" id="groupName" placeholder="Group Name">

<select id="processSelect">
  <option value="">-- Choose a process --</option>
  <option value="prosCons">Pros and Cons Analysis</option>
  <option value="mergeIdeas">Merge & Combine Ideas</option>
  <option value="ranking">Ranking & Elimination</option>
  <option value="peerFeedback">Peer Review & Feedback</option>
  <option value="storytelling">Storytelling & Perspective</option>
  <option value="wackyCorpse">Wacky Exquisite Corpse</option>
</select>

<button id="startBtn">Start / Join Process</button>
<button id="exportBtn">Export PDF</button>

<div id="processSteps"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import { getFirestore, doc, onSnapshot, setDoc, updateDoc, arrayUnion, serverTimestamp, getDoc } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-storage.js";

// Replace with your Firebase config
const firebaseConfig = {
  apiKey: "AIzaSyBAXjYxu0Nw59omDOk7qLQ2xzMRMRTBQ4g",
  authDomain: "art104-brainstorm.firebaseapp.com",
  projectId: "art104-brainstorm",
  storageBucket: "art104-brainstorm.firebasestorage.app",
  messagingSenderId: "333611557857",
  appId: "1:333611557857:web:610e1926f3886aaeb5a8a0",
  measurementId: "G-X3C9CHJ1BS"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const storage = getStorage(app);

const processes = {
  prosCons: ["List all 10 sketches.", "Discuss strengths and weaknesses.", "Write pros and cons.", "Decide strongest sketches.", "Narrow to 2–3 sketches to refine."],
  mergeIdeas: ["Review sketches, identify best elements.", "Sketch combinations of strong elements.", "Discuss which merged sketches are cohesive.", "Refine one merged idea.", "Evaluate against goals and adjust."],
  ranking: ["Establish evaluation criteria.", "Rank each sketch.", "Identify top 3 sketches.", "Remove weaker sketches, refine remaining.", "Finalize strongest sketch."],
  peerFeedback: ["Present sketches to other group.", "Collect feedback on strongest sketches.", "Discuss feedback and find common themes.", "Choose sketch fitting feedback.", "Refine into final idea."],
  storytelling: ["Imagine story for each sketch.", "Evaluate clearest story.", "Discuss how story supports goals.", "Select strongest narrative sketch.", "Refine into final idea."],
  wackyCorpse: ["Add your sketch (without seeing the full previous sketches).", "Next participant can only see the last uploaded image.", "Add a creative twist to the partial sketch.", "Repeat until all group members have contributed.", "Reveal the final combined sketch and discuss!"]
};

let currentDocRef;
let currentProcessKey;

// --------------------- CORE FUNCTIONS ---------------------
function startProcess() {
  const username = document.getElementById("username").value.trim();
  const groupName = document.getElementById("groupName").value.trim();
  currentProcessKey = document.getElementById("processSelect").value;

  if (!username || !groupName || !currentProcessKey) {
    alert("Enter your name, group name, and select a process.");
    return;
  }

  const processId = groupName.replace(/\s+/g,'_');
  currentDocRef = doc(db, "processes", processId);

  // Initialize Firestore document
  setDoc(currentDocRef, {
    groupName,
    steps: processes[currentProcessKey].map(text => ({text, checked:false, note:"", images:[] })),
    editing: {},
    lastUpdated: serverTimestamp()
  }, {merge:true});

  // Listen for changes in real-time
  onSnapshot(currentDocRef, (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      renderSteps(data.steps, currentProcessKey, data.editing || {});
    }
  });
}

// --------------------- RENDER STEPS WITH LIVE EDITING ---------------------
function renderSteps(steps, processKey, editingMap={}) {
  const stepsDiv = document.getElementById("processSteps");

  // Preserve text in notes to prevent disappearing while typing
  const currentNotes = {};
  steps.forEach((step, index) => {
    const ta = document.getElementById(`note${index}`);
    if (ta) currentNotes[index] = ta.value;
  });

  stepsDiv.innerHTML = '';
  const username = document.getElementById("username").value.trim();

  steps.forEach((step, index) => {
    const div = document.createElement('div');
    div.className = 'step';

    let imagesHTML = '';
    if (processKey === "wackyCorpse" && step.images.length) {
      const lastImage = step.images[step.images.length - 1];
      imagesHTML = `<img src="${lastImage}">`;
    } else {
      imagesHTML = step.images.map(url => `<img src="${url}">`).join('');
    }

    let editingLabel = '';
    if (editingMap[index] && editingMap[index] !== username) {
      editingLabel = `<div class="editing-label">Editing: ${editingMap[index]}</div>`;
    }

    div.innerHTML = `
      <label>
        <input type="checkbox" id="check${index}" ${step.checked ? 'checked':''} onchange="toggleCheck(${index}, this.checked)">
        ${step.text}
      </label>
      ${editingLabel}
      <textarea id="note${index}" placeholder="Add notes...">${currentNotes[index] !== undefined ? currentNotes[index] : step.note}</textarea>
      <input type="file" id="file${index}" accept="image/*" onchange="uploadCompressedImage(${index}, this.files[0])">
      <div id="images${index}">${imagesHTML}</div>
    `;
    stepsDiv.appendChild(div);

    const textarea = document.getElementById(`note${index}`);

    let typingTimeout;
    textarea.addEventListener('input', e => {
      updateNote(index, e.target.value);
      setEditing(index, true); 
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => setEditing(index, false), 1000); 
    });

    textarea.addEventListener('focus', () => setEditing(index, true));
    textarea.addEventListener('blur', () => setEditing(index, false));
  });
}

// --------------------- FIRESTORE UPDATES ---------------------
async function toggleCheck(index, checked) {
  await updateDoc(currentDocRef, { [`steps.${index}.checked`]: checked, lastUpdated: serverTimestamp() });
}

async function updateNote(index, note) {
  await updateDoc(currentDocRef, { [`steps.${index}.note`]: note, lastUpdated: serverTimestamp() });
}

function setEditing(stepIndex, isEditing) {
  const username = document.getElementById("username").value.trim();
  if (!username) return;
  const field = `editing.${stepIndex}`;
  if (isEditing) {
    updateDoc(currentDocRef, { [field]: username });
  } else {
    updateDoc(currentDocRef, { [field]: null });
  }
}

// --------------------- IMAGE COMPRESSION & UPLOAD ---------------------
async function uploadCompressedImage(index, file) {
  if (!file) return;
  const img = await loadImageForCompression(file);
  const canvas = document.createElement('canvas');
  const maxWidth = 800; 
  const scale = Math.min(maxWidth / img.width, 1);
  canvas.width = img.width * scale;
  canvas.height = img.height * scale;
  const ctx = canvas.getContext('2d');
  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
  canvas.toBlob(async (blob) => {
    const storageRef = ref(storage, `processImages/${currentDocRef.id}/${index}/${file.name}`);
    await uploadBytes(storageRef, blob);
    const url = await getDownloadURL(storageRef);
    await updateDoc(currentDocRef, { [`steps.${index}.images`]: arrayUnion(url), lastUpdated: serverTimestamp() });
  }, 'image/jpeg', 0.7);
}

function loadImageForCompression(file) {
  return new Promise(resolve => {
    const reader = new FileReader();
    reader.onload = e => {
      const img = new Image();
      img.src = e.target.result;
      img.onload = () => resolve(img);
    };
    reader.readAsDataURL(file);
  });
}

// --------------------- PDF EXPORT ---------------------
async function exportPDF() {
  const { jsPDF } = window.jspdf;
  const docPDF = new jsPDF();

  if (!currentDocRef) { alert("Please start or join a process first."); return; }
  const snapshot = await getDoc(currentDocRef);
  if (!snapshot.exists()) { alert("No data to export!"); return; }

  const data = snapshot.data();
  let y = 20;
  docPDF.setFontSize(16);
  docPDF.text(`${data.groupName} - ${currentProcessKey || ""}`, 20, y);
  y += 10;

  for (let i = 0; i < data.steps.length; i++) {
    const step = data.steps[i];
    const checked = step.checked ? "[✔] " : "[ ] ";
    docPDF.setFontSize(12);
    
    // Check if we need a new page for the step title
    if (y > 270) { docPDF.addPage(); y = 20; }
    
    docPDF.text(checked + step.text, 20, y);
    y += 8;

    if (step.note) {
      const splitNote = docPDF.splitTextToSize("Notes: " + step.note, 170);
      
      // Check if notes will fit on page
      if (y + (splitNote.length * 8) > 280) { docPDF.addPage(); y = 20; }
      
      docPDF.text(splitNote, 25, y);
      y += splitNote.length * 8;
    }

    // Process images sequentially with await
    for (let imgUrl of step.images) {
      try {
        // Check if image will fit on page BEFORE loading it
        if (y + 55 > 280) { docPDF.addPage(); y = 20; }
        
        const blob = await fetch(imgUrl).then(r => r.blob());
        const imgBase64 = await new Promise(resolve => {
          const reader = new FileReader();
          reader.onloadend = () => resolve(reader.result);
          reader.readAsDataURL(blob);
        });
        
        docPDF.addImage(imgBase64, 'JPEG', 25, y, 50, 50);
        y += 55;
        
      } catch(e) {
        console.error("Image failed to load:", e);
      }
    }
  }

  docPDF.save(`${data.groupName}_${currentProcessKey || "process"}.pdf`);
}

// --------------------- MAKE FUNCTIONS GLOBAL ---------------------
window.toggleCheck = toggleCheck;
window.uploadCompressedImage = uploadCompressedImage;

// --------------------- BUTTON LISTENERS ---------------------
document.getElementById('startBtn').addEventListener('click', startProcess);
document.getElementById('exportBtn').addEventListener('click', exportPDF);

</script>

</body>
</html>